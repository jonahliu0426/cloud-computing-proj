{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.graphqlWs = {}));\n})(this, function (exports) {\n  'use strict'; // Extremely small optimisation, reduces runtime prototype traversal\n\n  const baseHasOwnProperty = Object.prototype.hasOwnProperty;\n  /** @private */\n\n  function isObject(val) {\n    return typeof val === 'object' && val !== null;\n  }\n  /** @private */\n\n\n  function areGraphQLErrors(obj) {\n    return Array.isArray(obj) && // must be at least one error\n    obj.length > 0 && // error has at least a message\n    obj.every(ob => 'message' in ob);\n  }\n  /** @private */\n\n\n  function hasOwnProperty(obj, prop) {\n    return baseHasOwnProperty.call(obj, prop);\n  }\n  /** @private */\n\n\n  function hasOwnObjectProperty(obj, prop) {\n    return baseHasOwnProperty.call(obj, prop) && isObject(obj[prop]);\n  }\n  /** @private */\n\n\n  function hasOwnStringProperty(obj, prop) {\n    return baseHasOwnProperty.call(obj, prop) && typeof obj[prop] === 'string';\n  }\n  /**\n   * Limits the WebSocket close event reason to not exceed a length of one frame.\n   * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n   *\n   * @private\n   */\n\n\n  function limitCloseReason(reason, whenTooLong) {\n    return reason.length < 124 ? reason : whenTooLong;\n  }\n  /**\n   *\n   * common\n   *\n   */\n\n  /**\n   * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n   *\n   * @category Common\n   */\n\n\n  const GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n  /**\n   * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n   *\n   * @private\n   */\n\n  const DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n  /**\n   * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n   *\n   * @category Common\n   */\n\n  exports.CloseCode = void 0;\n\n  (function (CloseCode) {\n    CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n    CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n    CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n    CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n    /** Tried subscribing before connect ack */\n\n    CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n    CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n    CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n    CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n    CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n    /** Subscriber distinction is very important */\n\n    CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n    CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n  })(exports.CloseCode || (exports.CloseCode = {}));\n  /**\n   * Types of messages allowed to be sent by the client/server over the WS protocol.\n   *\n   * @category Common\n   */\n\n\n  exports.MessageType = void 0;\n\n  (function (MessageType) {\n    MessageType[\"ConnectionInit\"] = \"connection_init\";\n    MessageType[\"ConnectionAck\"] = \"connection_ack\";\n    MessageType[\"Ping\"] = \"ping\";\n    MessageType[\"Pong\"] = \"pong\";\n    MessageType[\"Subscribe\"] = \"subscribe\";\n    MessageType[\"Next\"] = \"next\";\n    MessageType[\"Error\"] = \"error\";\n    MessageType[\"Complete\"] = \"complete\";\n  })(exports.MessageType || (exports.MessageType = {}));\n  /**\n   * Checks if the provided value is a message.\n   *\n   * @category Common\n   */\n\n\n  function isMessage(val) {\n    if (isObject(val)) {\n      // all messages must have the `type` prop\n      if (!hasOwnStringProperty(val, 'type')) {\n        return false;\n      } // validate other properties depending on the `type`\n\n\n      switch (val.type) {\n        case exports.MessageType.ConnectionInit:\n          // the connection init message can have optional payload object\n          return !hasOwnProperty(val, 'payload') || val.payload === undefined || isObject(val.payload);\n\n        case exports.MessageType.ConnectionAck:\n        case exports.MessageType.Ping:\n        case exports.MessageType.Pong:\n          // the connection ack, ping and pong messages can have optional payload object too\n          return !hasOwnProperty(val, 'payload') || val.payload === undefined || isObject(val.payload);\n\n        case exports.MessageType.Subscribe:\n          return hasOwnStringProperty(val, 'id') && hasOwnObjectProperty(val, 'payload') && (!hasOwnProperty(val.payload, 'operationName') || val.payload.operationName === undefined || val.payload.operationName === null || typeof val.payload.operationName === 'string') && hasOwnStringProperty(val.payload, 'query') && (!hasOwnProperty(val.payload, 'variables') || val.payload.variables === undefined || val.payload.variables === null || hasOwnObjectProperty(val.payload, 'variables')) && (!hasOwnProperty(val.payload, 'extensions') || val.payload.extensions === undefined || val.payload.extensions === null || hasOwnObjectProperty(val.payload, 'extensions'));\n\n        case exports.MessageType.Next:\n          return hasOwnStringProperty(val, 'id') && hasOwnObjectProperty(val, 'payload');\n\n        case exports.MessageType.Error:\n          return hasOwnStringProperty(val, 'id') && areGraphQLErrors(val.payload);\n\n        case exports.MessageType.Complete:\n          return hasOwnStringProperty(val, 'id');\n\n        default:\n          return false;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Parses the raw websocket message data to a valid message.\n   *\n   * @category Common\n   */\n\n\n  function parseMessage(data, reviver) {\n    if (isMessage(data)) {\n      return data;\n    }\n\n    if (typeof data !== 'string') {\n      throw new Error('Message not parsable');\n    }\n\n    const message = JSON.parse(data, reviver);\n\n    if (!isMessage(message)) {\n      throw new Error('Invalid message');\n    }\n\n    return message;\n  }\n  /**\n   * Stringifies a valid message ready to be sent through the socket.\n   *\n   * @category Common\n   */\n\n\n  function stringifyMessage(msg, replacer) {\n    if (!isMessage(msg)) {\n      throw new Error('Cannot stringify invalid message');\n    }\n\n    return JSON.stringify(msg, replacer);\n  }\n  /**\n   *\n   * client\n   *\n   */\n\n  /**\n   * Creates a disposable GraphQL over WebSocket client.\n   *\n   * @category Client\n   */\n\n\n  function createClient(options) {\n    const {\n      url,\n      connectionParams,\n      lazy = true,\n      onNonLazyError = console.error,\n      lazyCloseTimeout = 0,\n      keepAlive = 0,\n      disablePong,\n      connectionAckWaitTimeout = 0,\n      retryAttempts = 5,\n      retryWait = async function randomisedExponentialBackoff(retries) {\n        let retryDelay = 1000; // start with 1s delay\n\n        for (let i = 0; i < retries; i++) {\n          retryDelay *= 2;\n        }\n\n        await new Promise(resolve => setTimeout(resolve, retryDelay + // add random timeout from 300ms to 3s\n        Math.floor(Math.random() * (3000 - 300) + 300)));\n      },\n      isFatalConnectionProblem = errOrCloseEvent => // non `CloseEvent`s are fatal by default\n      !isLikeCloseEvent(errOrCloseEvent),\n      on,\n      webSocketImpl,\n\n      /**\n       * Generates a v4 UUID to be used as the ID using `Math`\n       * as the random number generator. Supply your own generator\n       * in case you need more uniqueness.\n       *\n       * Reference: https://gist.github.com/jed/982883\n       */\n      generateID = function generateUUID() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n          const r = Math.random() * 16 | 0,\n                v = c == 'x' ? r : r & 0x3 | 0x8;\n          return v.toString(16);\n        });\n      },\n      jsonMessageReplacer: replacer,\n      jsonMessageReviver: reviver\n    } = options;\n    let ws;\n\n    if (webSocketImpl) {\n      if (!isWebSocket(webSocketImpl)) {\n        throw new Error('Invalid WebSocket implementation provided');\n      }\n\n      ws = webSocketImpl;\n    } else if (typeof WebSocket !== 'undefined') {\n      ws = WebSocket;\n    } else if (typeof global !== 'undefined') {\n      ws = global.WebSocket || // @ts-expect-error: Support more browsers\n      global.MozWebSocket;\n    } else if (typeof window !== 'undefined') {\n      ws = window.WebSocket || // @ts-expect-error: Support more browsers\n      window.MozWebSocket;\n    }\n\n    if (!ws) throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n    const WebSocketImpl = ws; // websocket status emitter, subscriptions are handled differently\n\n    const emitter = (() => {\n      const message = (() => {\n        const listeners = {};\n        return {\n          on(id, listener) {\n            listeners[id] = listener;\n            return () => {\n              delete listeners[id];\n            };\n          },\n\n          emit(message) {\n            var _a;\n\n            if ('id' in message) (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n          }\n\n        };\n      })();\n\n      const listeners = {\n        connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n        opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n        connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n        ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n        pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n        message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n        closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n        error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : []\n      };\n      return {\n        onMessage: message.on,\n\n        on(event, listener) {\n          const l = listeners[event];\n          l.push(listener);\n          return () => {\n            l.splice(l.indexOf(listener), 1);\n          };\n        },\n\n        emit(event, ...args) {\n          // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n          for (const listener of [...listeners[event]]) {\n            // @ts-expect-error: The args should fit\n            listener(...args);\n          }\n        }\n\n      };\n    })(); // invokes the callback either when an error or closed event is emitted,\n    // first one that gets called prevails, other emissions are ignored\n\n\n    function errorOrClosed(cb) {\n      const listening = [// errors are fatal and more critical than close events, throw them first\n      emitter.on('error', err => {\n        listening.forEach(unlisten => unlisten());\n        cb(err);\n      }), // closes can be graceful and not fatal, throw them second (if error didnt throw)\n      emitter.on('closed', event => {\n        listening.forEach(unlisten => unlisten());\n        cb(event);\n      })];\n    }\n\n    let connecting,\n        locks = 0,\n        retrying = false,\n        retries = 0,\n        disposed = false;\n\n    async function connect() {\n      const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise((connected, denied) => (async () => {\n        if (retrying) {\n          await retryWait(retries); // subscriptions might complete while waiting for retry\n\n          if (!locks) {\n            connecting = undefined;\n            return denied({\n              code: 1000,\n              reason: 'All Subscriptions Gone'\n            });\n          }\n\n          retries++;\n        }\n\n        emitter.emit('connecting');\n        const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n        let connectionAckTimeout, queuedPing;\n\n        function enqueuePing() {\n          if (isFinite(keepAlive) && keepAlive > 0) {\n            clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n\n            queuedPing = setTimeout(() => {\n              if (socket.readyState === WebSocketImpl.OPEN) {\n                socket.send(stringifyMessage({\n                  type: exports.MessageType.Ping\n                }));\n                emitter.emit('ping', false, undefined);\n              }\n            }, keepAlive);\n          }\n        }\n\n        errorOrClosed(errOrEvent => {\n          connecting = undefined;\n          clearTimeout(connectionAckTimeout);\n          clearTimeout(queuedPing);\n          denied(errOrEvent);\n        });\n\n        socket.onerror = err => emitter.emit('error', err);\n\n        socket.onclose = event => emitter.emit('closed', event);\n\n        socket.onopen = async () => {\n          try {\n            emitter.emit('opened', socket);\n            const payload = typeof connectionParams === 'function' ? await connectionParams() : connectionParams; // connectionParams might take too long causing the server to kick off the client\n            // the necessary error/close event is already reported - simply stop execution\n\n            if (socket.readyState !== WebSocketImpl.OPEN) return;\n            socket.send(stringifyMessage(payload ? {\n              type: exports.MessageType.ConnectionInit,\n              payload\n            } : {\n              type: exports.MessageType.ConnectionInit // payload is completely absent if not provided\n\n            }, replacer));\n\n            if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {\n              connectionAckTimeout = setTimeout(() => {\n                socket.close(exports.CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n              }, connectionAckWaitTimeout);\n            }\n\n            enqueuePing(); // enqueue ping (noop if disabled)\n          } catch (err) {\n            emitter.emit('error', err);\n            socket.close(exports.CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n          }\n        };\n\n        let acknowledged = false;\n\n        socket.onmessage = ({\n          data\n        }) => {\n          try {\n            const message = parseMessage(data, reviver);\n            emitter.emit('message', message);\n\n            if (message.type === 'ping' || message.type === 'pong') {\n              emitter.emit(message.type, true, message.payload); // received\n\n              if (message.type === 'pong') {\n                enqueuePing(); // enqueue next ping (noop if disabled)\n              } else if (!disablePong) {\n                // respond with pong on ping\n                socket.send(stringifyMessage(message.payload ? {\n                  type: exports.MessageType.Pong,\n                  payload: message.payload\n                } : {\n                  type: exports.MessageType.Pong // payload is completely absent if not provided\n\n                }));\n                emitter.emit('pong', false, message.payload);\n              }\n\n              return; // ping and pongs can be received whenever\n            }\n\n            if (acknowledged) return; // already connected and acknowledged\n\n            if (message.type !== exports.MessageType.ConnectionAck) throw new Error(`First message cannot be of type ${message.type}`);\n            clearTimeout(connectionAckTimeout);\n            acknowledged = true;\n            emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n\n            retrying = false; // future lazy connects are not retries\n\n            retries = 0; // reset the retries on connect\n\n            connected([socket, new Promise((_, reject) => errorOrClosed(reject))]);\n          } catch (err) {\n            socket.onmessage = null; // stop reading messages as soon as reading breaks once\n\n            emitter.emit('error', err);\n            socket.close(exports.CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n          }\n        };\n      })())); // if the provided socket is in a closing state, wait for the throw on close\n\n      if (socket.readyState === WebSocketImpl.CLOSING) await throwOnClose;\n\n      let release = () => {// releases this connection\n      };\n\n      const released = new Promise(resolve => release = resolve);\n      return [socket, release, Promise.race([// wait for\n      released.then(() => {\n        if (!locks) {\n          // and if no more locks are present, complete the connection\n          const complete = () => socket.close(1000, 'Normal Closure');\n\n          if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {\n            // if the keepalive is set, allow for the specified calmdown time and\n            // then complete. but only if no lock got created in the meantime and\n            // if the socket is still open\n            setTimeout(() => {\n              if (!locks && socket.readyState === WebSocketImpl.OPEN) complete();\n            }, lazyCloseTimeout);\n          } else {\n            // otherwise complete immediately\n            complete();\n          }\n        }\n      }), // or\n      throwOnClose])];\n    }\n    /**\n     * Checks the `connect` problem and evaluates if the client should retry.\n     */\n\n\n    function shouldRetryConnectOrThrow(errOrCloseEvent) {\n      // some close codes are worth reporting immediately\n      if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [exports.CloseCode.InternalServerError, exports.CloseCode.InternalClientError, exports.CloseCode.BadRequest, exports.CloseCode.BadResponse, exports.CloseCode.Unauthorized, // CloseCode.Forbidden, might grant access out after retry\n      exports.CloseCode.SubprotocolNotAcceptable, // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n      // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n      exports.CloseCode.SubscriberAlreadyExists, exports.CloseCode.TooManyInitialisationRequests].includes(errOrCloseEvent.code))) throw errOrCloseEvent; // client was disposed, no retries should proceed regardless\n\n      if (disposed) return false; // normal closure (possibly all subscriptions have completed)\n      // if no locks were acquired in the meantime, shouldnt try again\n\n      if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000) return locks > 0; // retries are not allowed or we tried to many times, report error\n\n      if (!retryAttempts || retries >= retryAttempts) throw errOrCloseEvent; // throw fatal connection problems immediately\n\n      if (isFatalConnectionProblem(errOrCloseEvent)) throw errOrCloseEvent; // looks good, start retrying\n\n      return retrying = true;\n    } // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n\n\n    if (!lazy) {\n      (async () => {\n        locks++;\n\n        for (;;) {\n          try {\n            const [,, throwOnClose] = await connect();\n            await throwOnClose; // will always throw because releaser is not used\n          } catch (errOrCloseEvent) {\n            try {\n              if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n            } catch (errOrCloseEvent) {\n              // report thrown error, no further retries\n              return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n            }\n          }\n        }\n      })();\n    }\n\n    return {\n      on: emitter.on,\n\n      subscribe(payload, sink) {\n        const id = generateID();\n\n        let done = false,\n            errored = false,\n            releaser = () => {\n          // for handling completions before connect\n          locks--;\n          done = true;\n        };\n\n        (async () => {\n          locks++;\n\n          for (;;) {\n            try {\n              const [socket, release, waitForReleaseOrThrowOnClose] = await connect(); // if done while waiting for connect, release the connection lock right away\n\n              if (done) return release();\n              const unlisten = emitter.onMessage(id, message => {\n                switch (message.type) {\n                  case exports.MessageType.Next:\n                    {\n                      sink.next(message.payload);\n                      return;\n                    }\n\n                  case exports.MessageType.Error:\n                    {\n                      errored = true, done = true;\n                      sink.error(message.payload);\n                      releaser();\n                      return;\n                    }\n\n                  case exports.MessageType.Complete:\n                    {\n                      done = true;\n                      releaser(); // release completes the sink\n\n                      return;\n                    }\n                }\n              });\n              socket.send(stringifyMessage({\n                id,\n                type: exports.MessageType.Subscribe,\n                payload\n              }, replacer));\n\n              releaser = () => {\n                if (!done && socket.readyState === WebSocketImpl.OPEN) // if not completed already and socket is open, send complete message to server on release\n                  socket.send(stringifyMessage({\n                    id,\n                    type: exports.MessageType.Complete\n                  }, replacer));\n                locks--;\n                done = true;\n                release();\n              }; // either the releaser will be called, connection completed and\n              // the promise resolved or the socket closed and the promise rejected.\n              // whatever happens though, we want to stop listening for messages\n\n\n              await waitForReleaseOrThrowOnClose.finally(unlisten);\n              return; // completed, shouldnt try again\n            } catch (errOrCloseEvent) {\n              if (!shouldRetryConnectOrThrow(errOrCloseEvent)) return;\n            }\n          }\n        })().then(() => {\n          // delivering either an error or a complete terminates the sequence\n          if (!errored) sink.complete();\n        }) // resolves on release or normal closure\n        .catch(err => {\n          sink.error(err);\n        }); // rejects on close events and errors\n\n        return () => {\n          // dispose only of active subscriptions\n          if (!done) releaser();\n        };\n      },\n\n      async dispose() {\n        disposed = true;\n\n        if (connecting) {\n          // if there is a connection, close it\n          const [socket] = await connecting;\n          socket.close(1000, 'Normal Closure');\n        }\n      }\n\n    };\n  }\n\n  function isLikeCloseEvent(val) {\n    return isObject(val) && 'code' in val && 'reason' in val;\n  }\n\n  function isFatalInternalCloseCode(code) {\n    if ([1000, 1001, 1006, 1005, 1012, 1013, 1013 // Bad Gateway\n    ].includes(code)) return false; // all other internal errors are fatal\n\n    return code >= 1000 && code <= 1999;\n  }\n\n  function isWebSocket(val) {\n    return typeof val === 'function' && 'constructor' in val && 'CLOSED' in val && 'CLOSING' in val && 'CONNECTING' in val && 'OPEN' in val;\n  }\n\n  exports.DEPRECATED_GRAPHQL_WS_PROTOCOL = DEPRECATED_GRAPHQL_WS_PROTOCOL;\n  exports.GRAPHQL_TRANSPORT_WS_PROTOCOL = GRAPHQL_TRANSPORT_WS_PROTOCOL;\n  exports.createClient = createClient;\n  exports.isMessage = isMessage;\n  exports.parseMessage = parseMessage;\n  exports.stringifyMessage = stringifyMessage;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/Users/jia78/Desktop/nyu-mscs/9223-cloud-computing/cloud-computing-proj/cloud-computing-proj/node_modules/graphql-ws/umd/graphql-ws.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","graphqlWs","baseHasOwnProperty","Object","prototype","hasOwnProperty","isObject","val","areGraphQLErrors","obj","Array","isArray","length","every","ob","prop","call","hasOwnObjectProperty","hasOwnStringProperty","limitCloseReason","reason","whenTooLong","GRAPHQL_TRANSPORT_WS_PROTOCOL","DEPRECATED_GRAPHQL_WS_PROTOCOL","CloseCode","MessageType","isMessage","type","ConnectionInit","payload","undefined","ConnectionAck","Ping","Pong","Subscribe","operationName","variables","extensions","Next","Error","Complete","parseMessage","data","reviver","message","JSON","parse","stringifyMessage","msg","replacer","stringify","createClient","options","url","connectionParams","lazy","onNonLazyError","console","error","lazyCloseTimeout","keepAlive","disablePong","connectionAckWaitTimeout","retryAttempts","retryWait","randomisedExponentialBackoff","retries","retryDelay","i","Promise","resolve","setTimeout","Math","floor","random","isFatalConnectionProblem","errOrCloseEvent","isLikeCloseEvent","on","webSocketImpl","generateID","generateUUID","replace","c","r","v","toString","jsonMessageReplacer","jsonMessageReviver","ws","isWebSocket","WebSocket","MozWebSocket","window","WebSocketImpl","emitter","listeners","id","listener","emit","_a","connecting","opened","connected","ping","pong","closed","onMessage","event","l","push","splice","indexOf","args","errorOrClosed","cb","listening","err","forEach","unlisten","locks","retrying","disposed","connect","socket","throwOnClose","denied","code","connectionAckTimeout","queuedPing","enqueuePing","isFinite","clearTimeout","readyState","OPEN","send","errOrEvent","onerror","onclose","onopen","close","ConnectionAcknowledgementTimeout","InternalClientError","acknowledged","onmessage","_","reject","BadResponse","CLOSING","release","released","race","then","complete","shouldRetryConnectOrThrow","isFatalInternalCloseCode","InternalServerError","BadRequest","Unauthorized","SubprotocolNotAcceptable","SubscriberAlreadyExists","TooManyInitialisationRequests","includes","subscribe","sink","done","errored","releaser","waitForReleaseOrThrowOnClose","next","finally","catch","dispose","defineProperty","value"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.graphqlWs = {}));\n})(this, (function (exports) { 'use strict';\n\n    // Extremely small optimisation, reduces runtime prototype traversal\n    const baseHasOwnProperty = Object.prototype.hasOwnProperty;\n    /** @private */\n    function isObject(val) {\n        return typeof val === 'object' && val !== null;\n    }\n    /** @private */\n    function areGraphQLErrors(obj) {\n        return (Array.isArray(obj) &&\n            // must be at least one error\n            obj.length > 0 &&\n            // error has at least a message\n            obj.every((ob) => 'message' in ob));\n    }\n    /** @private */\n    function hasOwnProperty(obj, prop) {\n        return baseHasOwnProperty.call(obj, prop);\n    }\n    /** @private */\n    function hasOwnObjectProperty(obj, prop) {\n        return baseHasOwnProperty.call(obj, prop) && isObject(obj[prop]);\n    }\n    /** @private */\n    function hasOwnStringProperty(obj, prop) {\n        return baseHasOwnProperty.call(obj, prop) && typeof obj[prop] === 'string';\n    }\n    /**\n     * Limits the WebSocket close event reason to not exceed a length of one frame.\n     * Reference: https://datatracker.ietf.org/doc/html/rfc6455#section-5.2.\n     *\n     * @private\n     */\n    function limitCloseReason(reason, whenTooLong) {\n        return reason.length < 124 ? reason : whenTooLong;\n    }\n\n    /**\n     *\n     * common\n     *\n     */\n    /**\n     * The WebSocket sub-protocol used for the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n     *\n     * @category Common\n     */\n    const GRAPHQL_TRANSPORT_WS_PROTOCOL = 'graphql-transport-ws';\n    /**\n     * The deprecated subprotocol used by [subscriptions-transport-ws](https://github.com/apollographql/subscriptions-transport-ws).\n     *\n     * @private\n     */\n    const DEPRECATED_GRAPHQL_WS_PROTOCOL = 'graphql-ws';\n    /**\n     * `graphql-ws` expected and standard close codes of the [GraphQL over WebSocket Protocol](/PROTOCOL.md).\n     *\n     * @category Common\n     */\n    exports.CloseCode = void 0;\n    (function (CloseCode) {\n        CloseCode[CloseCode[\"InternalServerError\"] = 4500] = \"InternalServerError\";\n        CloseCode[CloseCode[\"InternalClientError\"] = 4005] = \"InternalClientError\";\n        CloseCode[CloseCode[\"BadRequest\"] = 4400] = \"BadRequest\";\n        CloseCode[CloseCode[\"BadResponse\"] = 4004] = \"BadResponse\";\n        /** Tried subscribing before connect ack */\n        CloseCode[CloseCode[\"Unauthorized\"] = 4401] = \"Unauthorized\";\n        CloseCode[CloseCode[\"Forbidden\"] = 4403] = \"Forbidden\";\n        CloseCode[CloseCode[\"SubprotocolNotAcceptable\"] = 4406] = \"SubprotocolNotAcceptable\";\n        CloseCode[CloseCode[\"ConnectionInitialisationTimeout\"] = 4408] = \"ConnectionInitialisationTimeout\";\n        CloseCode[CloseCode[\"ConnectionAcknowledgementTimeout\"] = 4504] = \"ConnectionAcknowledgementTimeout\";\n        /** Subscriber distinction is very important */\n        CloseCode[CloseCode[\"SubscriberAlreadyExists\"] = 4409] = \"SubscriberAlreadyExists\";\n        CloseCode[CloseCode[\"TooManyInitialisationRequests\"] = 4429] = \"TooManyInitialisationRequests\";\n    })(exports.CloseCode || (exports.CloseCode = {}));\n    /**\n     * Types of messages allowed to be sent by the client/server over the WS protocol.\n     *\n     * @category Common\n     */\n    exports.MessageType = void 0;\n    (function (MessageType) {\n        MessageType[\"ConnectionInit\"] = \"connection_init\";\n        MessageType[\"ConnectionAck\"] = \"connection_ack\";\n        MessageType[\"Ping\"] = \"ping\";\n        MessageType[\"Pong\"] = \"pong\";\n        MessageType[\"Subscribe\"] = \"subscribe\";\n        MessageType[\"Next\"] = \"next\";\n        MessageType[\"Error\"] = \"error\";\n        MessageType[\"Complete\"] = \"complete\";\n    })(exports.MessageType || (exports.MessageType = {}));\n    /**\n     * Checks if the provided value is a message.\n     *\n     * @category Common\n     */\n    function isMessage(val) {\n        if (isObject(val)) {\n            // all messages must have the `type` prop\n            if (!hasOwnStringProperty(val, 'type')) {\n                return false;\n            }\n            // validate other properties depending on the `type`\n            switch (val.type) {\n                case exports.MessageType.ConnectionInit:\n                    // the connection init message can have optional payload object\n                    return (!hasOwnProperty(val, 'payload') ||\n                        val.payload === undefined ||\n                        isObject(val.payload));\n                case exports.MessageType.ConnectionAck:\n                case exports.MessageType.Ping:\n                case exports.MessageType.Pong:\n                    // the connection ack, ping and pong messages can have optional payload object too\n                    return (!hasOwnProperty(val, 'payload') ||\n                        val.payload === undefined ||\n                        isObject(val.payload));\n                case exports.MessageType.Subscribe:\n                    return (hasOwnStringProperty(val, 'id') &&\n                        hasOwnObjectProperty(val, 'payload') &&\n                        (!hasOwnProperty(val.payload, 'operationName') ||\n                            val.payload.operationName === undefined ||\n                            val.payload.operationName === null ||\n                            typeof val.payload.operationName === 'string') &&\n                        hasOwnStringProperty(val.payload, 'query') &&\n                        (!hasOwnProperty(val.payload, 'variables') ||\n                            val.payload.variables === undefined ||\n                            val.payload.variables === null ||\n                            hasOwnObjectProperty(val.payload, 'variables')) &&\n                        (!hasOwnProperty(val.payload, 'extensions') ||\n                            val.payload.extensions === undefined ||\n                            val.payload.extensions === null ||\n                            hasOwnObjectProperty(val.payload, 'extensions')));\n                case exports.MessageType.Next:\n                    return (hasOwnStringProperty(val, 'id') &&\n                        hasOwnObjectProperty(val, 'payload'));\n                case exports.MessageType.Error:\n                    return hasOwnStringProperty(val, 'id') && areGraphQLErrors(val.payload);\n                case exports.MessageType.Complete:\n                    return hasOwnStringProperty(val, 'id');\n                default:\n                    return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * Parses the raw websocket message data to a valid message.\n     *\n     * @category Common\n     */\n    function parseMessage(data, reviver) {\n        if (isMessage(data)) {\n            return data;\n        }\n        if (typeof data !== 'string') {\n            throw new Error('Message not parsable');\n        }\n        const message = JSON.parse(data, reviver);\n        if (!isMessage(message)) {\n            throw new Error('Invalid message');\n        }\n        return message;\n    }\n    /**\n     * Stringifies a valid message ready to be sent through the socket.\n     *\n     * @category Common\n     */\n    function stringifyMessage(msg, replacer) {\n        if (!isMessage(msg)) {\n            throw new Error('Cannot stringify invalid message');\n        }\n        return JSON.stringify(msg, replacer);\n    }\n\n    /**\n     *\n     * client\n     *\n     */\n    /**\n     * Creates a disposable GraphQL over WebSocket client.\n     *\n     * @category Client\n     */\n    function createClient(options) {\n        const { url, connectionParams, lazy = true, onNonLazyError = console.error, lazyCloseTimeout = 0, keepAlive = 0, disablePong, connectionAckWaitTimeout = 0, retryAttempts = 5, retryWait = async function randomisedExponentialBackoff(retries) {\n            let retryDelay = 1000; // start with 1s delay\n            for (let i = 0; i < retries; i++) {\n                retryDelay *= 2;\n            }\n            await new Promise((resolve) => setTimeout(resolve, retryDelay +\n                // add random timeout from 300ms to 3s\n                Math.floor(Math.random() * (3000 - 300) + 300)));\n        }, isFatalConnectionProblem = (errOrCloseEvent) => \n        // non `CloseEvent`s are fatal by default\n        !isLikeCloseEvent(errOrCloseEvent), on, webSocketImpl, \n        /**\n         * Generates a v4 UUID to be used as the ID using `Math`\n         * as the random number generator. Supply your own generator\n         * in case you need more uniqueness.\n         *\n         * Reference: https://gist.github.com/jed/982883\n         */\n        generateID = function generateUUID() {\n            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n                const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n                return v.toString(16);\n            });\n        }, jsonMessageReplacer: replacer, jsonMessageReviver: reviver, } = options;\n        let ws;\n        if (webSocketImpl) {\n            if (!isWebSocket(webSocketImpl)) {\n                throw new Error('Invalid WebSocket implementation provided');\n            }\n            ws = webSocketImpl;\n        }\n        else if (typeof WebSocket !== 'undefined') {\n            ws = WebSocket;\n        }\n        else if (typeof global !== 'undefined') {\n            ws =\n                global.WebSocket ||\n                    // @ts-expect-error: Support more browsers\n                    global.MozWebSocket;\n        }\n        else if (typeof window !== 'undefined') {\n            ws =\n                window.WebSocket ||\n                    // @ts-expect-error: Support more browsers\n                    window.MozWebSocket;\n        }\n        if (!ws)\n            throw new Error(\"WebSocket implementation missing; on Node you can `import WebSocket from 'ws';` and pass `webSocketImpl: WebSocket` to `createClient`\");\n        const WebSocketImpl = ws;\n        // websocket status emitter, subscriptions are handled differently\n        const emitter = (() => {\n            const message = (() => {\n                const listeners = {};\n                return {\n                    on(id, listener) {\n                        listeners[id] = listener;\n                        return () => {\n                            delete listeners[id];\n                        };\n                    },\n                    emit(message) {\n                        var _a;\n                        if ('id' in message)\n                            (_a = listeners[message.id]) === null || _a === void 0 ? void 0 : _a.call(listeners, message);\n                    },\n                };\n            })();\n            const listeners = {\n                connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],\n                opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],\n                connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],\n                ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],\n                pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],\n                message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],\n                closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],\n                error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : [],\n            };\n            return {\n                onMessage: message.on,\n                on(event, listener) {\n                    const l = listeners[event];\n                    l.push(listener);\n                    return () => {\n                        l.splice(l.indexOf(listener), 1);\n                    };\n                },\n                emit(event, ...args) {\n                    // we copy the listeners so that unlistens dont \"pull the rug under our feet\"\n                    for (const listener of [...listeners[event]]) {\n                        // @ts-expect-error: The args should fit\n                        listener(...args);\n                    }\n                },\n            };\n        })();\n        // invokes the callback either when an error or closed event is emitted,\n        // first one that gets called prevails, other emissions are ignored\n        function errorOrClosed(cb) {\n            const listening = [\n                // errors are fatal and more critical than close events, throw them first\n                emitter.on('error', (err) => {\n                    listening.forEach((unlisten) => unlisten());\n                    cb(err);\n                }),\n                // closes can be graceful and not fatal, throw them second (if error didnt throw)\n                emitter.on('closed', (event) => {\n                    listening.forEach((unlisten) => unlisten());\n                    cb(event);\n                }),\n            ];\n        }\n        let connecting, locks = 0, retrying = false, retries = 0, disposed = false;\n        async function connect() {\n            const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : (connecting = new Promise((connected, denied) => (async () => {\n                if (retrying) {\n                    await retryWait(retries);\n                    // subscriptions might complete while waiting for retry\n                    if (!locks) {\n                        connecting = undefined;\n                        return denied({ code: 1000, reason: 'All Subscriptions Gone' });\n                    }\n                    retries++;\n                }\n                emitter.emit('connecting');\n                const socket = new WebSocketImpl(typeof url === 'function' ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);\n                let connectionAckTimeout, queuedPing;\n                function enqueuePing() {\n                    if (isFinite(keepAlive) && keepAlive > 0) {\n                        clearTimeout(queuedPing); // in case where a pong was received before a ping (this is valid behaviour)\n                        queuedPing = setTimeout(() => {\n                            if (socket.readyState === WebSocketImpl.OPEN) {\n                                socket.send(stringifyMessage({ type: exports.MessageType.Ping }));\n                                emitter.emit('ping', false, undefined);\n                            }\n                        }, keepAlive);\n                    }\n                }\n                errorOrClosed((errOrEvent) => {\n                    connecting = undefined;\n                    clearTimeout(connectionAckTimeout);\n                    clearTimeout(queuedPing);\n                    denied(errOrEvent);\n                });\n                socket.onerror = (err) => emitter.emit('error', err);\n                socket.onclose = (event) => emitter.emit('closed', event);\n                socket.onopen = async () => {\n                    try {\n                        emitter.emit('opened', socket);\n                        const payload = typeof connectionParams === 'function'\n                            ? await connectionParams()\n                            : connectionParams;\n                        // connectionParams might take too long causing the server to kick off the client\n                        // the necessary error/close event is already reported - simply stop execution\n                        if (socket.readyState !== WebSocketImpl.OPEN)\n                            return;\n                        socket.send(stringifyMessage(payload\n                            ? {\n                                type: exports.MessageType.ConnectionInit,\n                                payload,\n                            }\n                            : {\n                                type: exports.MessageType.ConnectionInit,\n                                // payload is completely absent if not provided\n                            }, replacer));\n                        if (isFinite(connectionAckWaitTimeout) &&\n                            connectionAckWaitTimeout > 0) {\n                            connectionAckTimeout = setTimeout(() => {\n                                socket.close(exports.CloseCode.ConnectionAcknowledgementTimeout, 'Connection acknowledgement timeout');\n                            }, connectionAckWaitTimeout);\n                        }\n                        enqueuePing(); // enqueue ping (noop if disabled)\n                    }\n                    catch (err) {\n                        emitter.emit('error', err);\n                        socket.close(exports.CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Internal client error'));\n                    }\n                };\n                let acknowledged = false;\n                socket.onmessage = ({ data }) => {\n                    try {\n                        const message = parseMessage(data, reviver);\n                        emitter.emit('message', message);\n                        if (message.type === 'ping' || message.type === 'pong') {\n                            emitter.emit(message.type, true, message.payload); // received\n                            if (message.type === 'pong') {\n                                enqueuePing(); // enqueue next ping (noop if disabled)\n                            }\n                            else if (!disablePong) {\n                                // respond with pong on ping\n                                socket.send(stringifyMessage(message.payload\n                                    ? {\n                                        type: exports.MessageType.Pong,\n                                        payload: message.payload,\n                                    }\n                                    : {\n                                        type: exports.MessageType.Pong,\n                                        // payload is completely absent if not provided\n                                    }));\n                                emitter.emit('pong', false, message.payload);\n                            }\n                            return; // ping and pongs can be received whenever\n                        }\n                        if (acknowledged)\n                            return; // already connected and acknowledged\n                        if (message.type !== exports.MessageType.ConnectionAck)\n                            throw new Error(`First message cannot be of type ${message.type}`);\n                        clearTimeout(connectionAckTimeout);\n                        acknowledged = true;\n                        emitter.emit('connected', socket, message.payload); // connected = socket opened + acknowledged\n                        retrying = false; // future lazy connects are not retries\n                        retries = 0; // reset the retries on connect\n                        connected([\n                            socket,\n                            new Promise((_, reject) => errorOrClosed(reject)),\n                        ]);\n                    }\n                    catch (err) {\n                        socket.onmessage = null; // stop reading messages as soon as reading breaks once\n                        emitter.emit('error', err);\n                        socket.close(exports.CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, 'Bad response'));\n                    }\n                };\n            })())));\n            // if the provided socket is in a closing state, wait for the throw on close\n            if (socket.readyState === WebSocketImpl.CLOSING)\n                await throwOnClose;\n            let release = () => {\n                // releases this connection\n            };\n            const released = new Promise((resolve) => (release = resolve));\n            return [\n                socket,\n                release,\n                Promise.race([\n                    // wait for\n                    released.then(() => {\n                        if (!locks) {\n                            // and if no more locks are present, complete the connection\n                            const complete = () => socket.close(1000, 'Normal Closure');\n                            if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {\n                                // if the keepalive is set, allow for the specified calmdown time and\n                                // then complete. but only if no lock got created in the meantime and\n                                // if the socket is still open\n                                setTimeout(() => {\n                                    if (!locks && socket.readyState === WebSocketImpl.OPEN)\n                                        complete();\n                                }, lazyCloseTimeout);\n                            }\n                            else {\n                                // otherwise complete immediately\n                                complete();\n                            }\n                        }\n                    }),\n                    // or\n                    throwOnClose,\n                ]),\n            ];\n        }\n        /**\n         * Checks the `connect` problem and evaluates if the client should retry.\n         */\n        function shouldRetryConnectOrThrow(errOrCloseEvent) {\n            // some close codes are worth reporting immediately\n            if (isLikeCloseEvent(errOrCloseEvent) &&\n                (isFatalInternalCloseCode(errOrCloseEvent.code) ||\n                    [\n                        exports.CloseCode.InternalServerError,\n                        exports.CloseCode.InternalClientError,\n                        exports.CloseCode.BadRequest,\n                        exports.CloseCode.BadResponse,\n                        exports.CloseCode.Unauthorized,\n                        // CloseCode.Forbidden, might grant access out after retry\n                        exports.CloseCode.SubprotocolNotAcceptable,\n                        // CloseCode.ConnectionInitialisationTimeout, might not time out after retry\n                        // CloseCode.ConnectionAcknowledgementTimeout, might not time out after retry\n                        exports.CloseCode.SubscriberAlreadyExists,\n                        exports.CloseCode.TooManyInitialisationRequests,\n                    ].includes(errOrCloseEvent.code)))\n                throw errOrCloseEvent;\n            // client was disposed, no retries should proceed regardless\n            if (disposed)\n                return false;\n            // normal closure (possibly all subscriptions have completed)\n            // if no locks were acquired in the meantime, shouldnt try again\n            if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1000)\n                return locks > 0;\n            // retries are not allowed or we tried to many times, report error\n            if (!retryAttempts || retries >= retryAttempts)\n                throw errOrCloseEvent;\n            // throw fatal connection problems immediately\n            if (isFatalConnectionProblem(errOrCloseEvent))\n                throw errOrCloseEvent;\n            // looks good, start retrying\n            return (retrying = true);\n        }\n        // in non-lazy (hot?) mode always hold one connection lock to persist the socket\n        if (!lazy) {\n            (async () => {\n                locks++;\n                for (;;) {\n                    try {\n                        const [, , throwOnClose] = await connect();\n                        await throwOnClose; // will always throw because releaser is not used\n                    }\n                    catch (errOrCloseEvent) {\n                        try {\n                            if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                                return;\n                        }\n                        catch (errOrCloseEvent) {\n                            // report thrown error, no further retries\n                            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent);\n                        }\n                    }\n                }\n            })();\n        }\n        return {\n            on: emitter.on,\n            subscribe(payload, sink) {\n                const id = generateID();\n                let done = false, errored = false, releaser = () => {\n                    // for handling completions before connect\n                    locks--;\n                    done = true;\n                };\n                (async () => {\n                    locks++;\n                    for (;;) {\n                        try {\n                            const [socket, release, waitForReleaseOrThrowOnClose] = await connect();\n                            // if done while waiting for connect, release the connection lock right away\n                            if (done)\n                                return release();\n                            const unlisten = emitter.onMessage(id, (message) => {\n                                switch (message.type) {\n                                    case exports.MessageType.Next: {\n                                        sink.next(message.payload);\n                                        return;\n                                    }\n                                    case exports.MessageType.Error: {\n                                        (errored = true), (done = true);\n                                        sink.error(message.payload);\n                                        releaser();\n                                        return;\n                                    }\n                                    case exports.MessageType.Complete: {\n                                        done = true;\n                                        releaser(); // release completes the sink\n                                        return;\n                                    }\n                                }\n                            });\n                            socket.send(stringifyMessage({\n                                id,\n                                type: exports.MessageType.Subscribe,\n                                payload,\n                            }, replacer));\n                            releaser = () => {\n                                if (!done && socket.readyState === WebSocketImpl.OPEN)\n                                    // if not completed already and socket is open, send complete message to server on release\n                                    socket.send(stringifyMessage({\n                                        id,\n                                        type: exports.MessageType.Complete,\n                                    }, replacer));\n                                locks--;\n                                done = true;\n                                release();\n                            };\n                            // either the releaser will be called, connection completed and\n                            // the promise resolved or the socket closed and the promise rejected.\n                            // whatever happens though, we want to stop listening for messages\n                            await waitForReleaseOrThrowOnClose.finally(unlisten);\n                            return; // completed, shouldnt try again\n                        }\n                        catch (errOrCloseEvent) {\n                            if (!shouldRetryConnectOrThrow(errOrCloseEvent))\n                                return;\n                        }\n                    }\n                })()\n                    .then(() => {\n                    // delivering either an error or a complete terminates the sequence\n                    if (!errored)\n                        sink.complete();\n                }) // resolves on release or normal closure\n                    .catch((err) => {\n                    sink.error(err);\n                }); // rejects on close events and errors\n                return () => {\n                    // dispose only of active subscriptions\n                    if (!done)\n                        releaser();\n                };\n            },\n            async dispose() {\n                disposed = true;\n                if (connecting) {\n                    // if there is a connection, close it\n                    const [socket] = await connecting;\n                    socket.close(1000, 'Normal Closure');\n                }\n            },\n        };\n    }\n    function isLikeCloseEvent(val) {\n        return isObject(val) && 'code' in val && 'reason' in val;\n    }\n    function isFatalInternalCloseCode(code) {\n        if ([\n            1000,\n            1001,\n            1006,\n            1005,\n            1012,\n            1013,\n            1013, // Bad Gateway\n        ].includes(code))\n            return false;\n        // all other internal errors are fatal\n        return code >= 1000 && code <= 1999;\n    }\n    function isWebSocket(val) {\n        return (typeof val === 'function' &&\n            'constructor' in val &&\n            'CLOSED' in val &&\n            'CLOSING' in val &&\n            'CONNECTING' in val &&\n            'OPEN' in val);\n    }\n\n    exports.DEPRECATED_GRAPHQL_WS_PROTOCOL = DEPRECATED_GRAPHQL_WS_PROTOCOL;\n    exports.GRAPHQL_TRANSPORT_WS_PROTOCOL = GRAPHQL_TRANSPORT_WS_PROTOCOL;\n    exports.createClient = createClient;\n    exports.isMessage = isMessage;\n    exports.parseMessage = parseMessage;\n    exports.stringifyMessage = stringifyMessage;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"]},"metadata":{},"sourceType":"script"}